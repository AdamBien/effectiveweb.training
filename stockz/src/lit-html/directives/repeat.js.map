{"version":3,"file":"repeat.js","sourceRoot":"","sources":["../src/directives/repeat.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {directive, Directive, NodePart, removeNodes, reparentNodes} from '../lit-html.js';\n\nexport type KeyFn<T> = (item: T) => any;\nexport type ItemTemplate<T> = (item: T, index: number) => any;\n\nconst keyMapCache = new WeakMap<NodePart, Map<any, NodePart>>();\n\nfunction cleanMap(part: NodePart, key: any, map: Map<any, NodePart>) {\n  if (!part.startNode.parentNode) {\n    map.delete(key);\n  }\n}\n\nexport function repeat<T>(\n    items: T[], keyFn: KeyFn<T>, template: ItemTemplate<T>):\n    Directive<NodePart>;\nexport function repeat<T>(\n    items: T[], template: ItemTemplate<T>): Directive<NodePart>;\nexport function repeat<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n    template?: ItemTemplate<T>): Directive<NodePart> {\n  let keyFn: KeyFn<T>;\n  if (arguments.length === 2) {\n    template = keyFnOrTemplate;\n  } else if (arguments.length === 3) {\n    keyFn = keyFnOrTemplate as KeyFn<T>;\n  }\n\n  return directive((part: NodePart): void => {\n    let keyMap = keyMapCache.get(part);\n    if (keyMap === undefined) {\n      keyMap = new Map();\n      keyMapCache.set(part, keyMap);\n    }\n    const container = part.startNode.parentNode as HTMLElement | ShadowRoot |\n        DocumentFragment;\n    let index = -1;\n    let currentMarker = part.startNode.nextSibling!;\n\n    for (const item of items) {\n      let result;\n      let key;\n      try {\n        ++index;\n        result = template !(item, index);\n        key = keyFn ? keyFn(item) : index;\n      } catch (e) {\n        console.error(e);\n        continue;\n      }\n\n      // Try to reuse a part\n      let itemPart = keyMap.get(key);\n      if (itemPart === undefined) {\n        // TODO(justinfagnani): We really want to avoid manual marker creation\n        // here and instead use something like part.insertBeforePart(). This\n        // requires a little refactoring, like iterating through values and\n        // existing parts like NodePart#_setIterable does. We can also remove\n        // keyMapCache and use part._value instead.\n        // But... repeat() is badly in need of rewriting, so we'll do this for\n        // now and revisit soon.\n        const marker = document.createComment('');\n        const endNode = document.createComment('');\n        container.insertBefore(marker, currentMarker);\n        container.insertBefore(endNode, currentMarker);\n        itemPart = new NodePart(part.templateFactory);\n        itemPart.insertAfterNode(marker);\n        if (key !== undefined) {\n          keyMap.set(key, itemPart);\n        }\n      } else if (currentMarker !== itemPart.startNode) {\n        // Existing part in the wrong position\n        const end = itemPart.endNode.nextSibling!;\n        if (currentMarker !== end) {\n          reparentNodes(container, itemPart.startNode, end, currentMarker);\n        }\n      } else {\n        // else part is in the correct position already\n        currentMarker = itemPart.endNode.nextSibling!;\n      }\n\n      itemPart.setValue(result);\n      itemPart.commit();\n    }\n\n    // Cleanup\n    if (currentMarker !== part.endNode) {\n      removeNodes(container, currentMarker, part.endNode);\n      keyMap.forEach(cleanMap);\n    }\n  });\n}\n"]}