{"version":3,"file":"when.js","sourceRoot":"","sources":["../src/directives/when.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAEH,OAAO,EAAC,SAAS,EAAa,QAAQ,EAAE,aAAa,EAAC,MAAM,gBAAgB,CAAC;AAS7E,MAAM,UAAU,GAAG,IAAI,OAAO,EAAuB,CAAC;AAEtD;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,MAAM,CAAC,MAAM,IAAI,GACb,CAAC,SAAc,EAAE,SAAoB,EAAE,UAAqB,EACpC,EAAE,CAAC,SAAS,CAAC,CAAC,UAAoB,EAAE,EAAE;IACxD,IAAI,KAAK,GAAG,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IAEvC,iDAAiD;IACjD,IAAI,KAAK,KAAK,SAAS,EAAE;QACvB,6DAA6D;QAC7D,oEAAoE;QACpE,0BAA0B;QAC1B,KAAK,GAAG;YACN,QAAQ,EAAE,IAAI,QAAQ,CAAC,UAAU,CAAC,eAAe,CAAC;YAClD,SAAS,EAAE,IAAI,QAAQ,CAAC,UAAU,CAAC,eAAe,CAAC;YACnD,cAAc,EAAE,QAAQ,CAAC,sBAAsB,EAAE;SAClD,CAAC;QACF,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;QAElC,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QAC1C,KAAK,CAAC,SAAS,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;KAC5C;IAED,sEAAsE;IACtE,uBAAuB;IACvB,MAAM,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC;IAC9D,MAAM,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;IAEzD,0DAA0D;IAC1D,IAAI,CAAC,CAAC,SAAS,KAAK,KAAK,CAAC,aAAa,EAAE;QACvC,mEAAmE;QACnE,gCAAgC;QAChC,MAAM,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC;QAE9D,wDAAwD;QACxD,IAAI,QAAQ,CAAC,KAAK,EAAE;YAClB,UAAU,CAAC,SAAS,CAAC,UAAW,CAAC,WAAW,CACxC,KAAK,CAAC,cAAc,CAAC,CAAC;SAC3B;QAED,sDAAsD;QACtD,IAAI,QAAQ,CAAC,KAAK,EAAE;YAClB,aAAa,CACT,KAAK,CAAC,cAAc,EACpB,QAAQ,CAAC,SAAS,EAClB,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;SACnC;KACF;IAED,4BAA4B;IAC5B,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;IAC7B,QAAQ,CAAC,MAAM,EAAE,CAAC;IAElB,KAAK,CAAC,aAAa,GAAG,CAAC,CAAC,SAAS,CAAC;AACpC,CAAC,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {directive, Directive, NodePart, reparentNodes} from '../lit-html.js';\n\ninterface PartCache {\n  truePart: NodePart;\n  falsePart: NodePart;\n  prevCondition?: boolean;\n  cacheContainer: DocumentFragment;\n}\n\nconst partCaches = new WeakMap<NodePart, PartCache>();\n\n/**\n * Efficiently switches between two templates based on the given condition. The\n * rendered content is cached, and re-used when switching conditions. Templates\n * are evaluated lazily, so the passed values must be functions.\n *\n * While this directive can render any regular part, it makes the most sense\n * when used with TemplateResulte since most other values are dirty checked\n * already.\n *\n * Example:\n *\n * let checked = false;\n *\n * html`\n *   when(checked, () => html`Checkmark is checked`, () => html`Checkmark is not\n * checked`);\n * `\n *\n * @param condition the condition to test truthiness against\n * @param trueValue the value to render given a true condition\n * @param falseValue the value to render given a false condition\n */\nexport const when =\n    (condition: any, trueValue: () => any, falseValue: () => any):\n        Directive<NodePart> => directive((parentPart: NodePart) => {\n          let cache = partCaches.get(parentPart);\n\n          // Create a new cache if this is the first render\n          if (cache === undefined) {\n            // Cache consists of two parts, one for each condition, and a\n            // docment fragment which we cache the nodes of the condition that's\n            // not currently rendered.\n            cache = {\n              truePart: new NodePart(parentPart.templateFactory),\n              falsePart: new NodePart(parentPart.templateFactory),\n              cacheContainer: document.createDocumentFragment(),\n            };\n            partCaches.set(parentPart, cache);\n\n            cache.truePart.appendIntoPart(parentPart);\n            cache.falsePart.appendIntoPart(parentPart);\n          }\n\n          // Based on the condition, select which part to render and which value\n          // to set on that part.\n          const nextPart = condition ? cache.truePart : cache.falsePart;\n          const nextValue = condition ? trueValue() : falseValue();\n\n          // If we switched condition, swap nodes to/from the cache.\n          if (!!condition !== cache.prevCondition) {\n            // Get the part which was rendered for the opposite condition. This\n            // should be added to the cache.\n            const prevPart = condition ? cache.falsePart : cache.truePart;\n\n            // If the next part was rendered, take it from the cache\n            if (nextPart.value) {\n              parentPart.startNode.parentNode!.appendChild(\n                  cache.cacheContainer);\n            }\n\n            // If the prev part was rendered, move it to the cache\n            if (prevPart.value) {\n              reparentNodes(\n                  cache.cacheContainer,\n                  prevPart.startNode,\n                  prevPart.endNode.nextSibling);\n            }\n          }\n\n          // Set the next part's value\n          nextPart.setValue(nextValue);\n          nextPart.commit();\n\n          cache.prevCondition = !!condition;\n        });"]}