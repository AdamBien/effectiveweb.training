{"version":3,"file":"guard.js","sourceRoot":"","sources":["../src/directives/guard.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAEH,OAAO,EAAC,SAAS,EAAsB,MAAM,gBAAgB,CAAC;AAE9D,MAAM,mBAAmB,GAAG,IAAI,OAAO,EAAiB,CAAC;AAEzD;;;;;;;;;;;;;;;;;;GAkBG;AACH,MAAM,CAAC,MAAM,KAAK,GACd,CAAC,UAAe,EAAE,OAAkB,EAAuB,EAAE,CACzD,SAAS,CAAC,CAAC,IAAc,EAAQ,EAAE;IACjC,kCAAkC;IAClC,IAAI,mBAAmB,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,UAAU,EAAE;QAChD,OAAO;KACR;IAED,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC;IACzB,mBAAmB,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {directive, Directive, NodePart} from '../lit-html.js';\n\nconst previousExpressions = new WeakMap<NodePart, any>();\n\n/**\n * Creates a guard directive. Prevents any re-render until the identity of the\n * expression changes, for example when a primitive changes value or when an\n * object reference changes.\n *\n * This useful with immutable data patterns, by preventing expensive work until\n * data updates. Example:\n *\n * html`\n *   <div>\n *     ${guard(items, () => items.map(item => html`${item}`))}\n *   </div>\n * `\n *\n * In this case, items are mapped over only when the array reference changes.\n *\n * @param expression the expression to check before re-rendering\n * @param valueFn function which returns the render value\n */\nexport const guard =\n    (expression: any, valueFn: () => any): Directive<NodePart> =>\n        directive((part: NodePart): void => {\n          // Dirty check previous expression\n          if (previousExpressions.get(part) === expression) {\n            return;\n          }\n\n          part.setValue(valueFn());\n          previousExpressions.set(part, expression);\n        });\n"]}