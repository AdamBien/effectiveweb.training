{"version":3,"file":"shady-render.js","sourceRoot":"","sources":["../src/lib/shady-render.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {removeNodes} from './dom.js';\nimport {insertNodeIntoTemplate, removeNodesFromTemplate} from './modify-template.js';\nimport {TemplateContainer} from './render.js';\nimport {templateCaches} from './template-factory.js';\nimport {TemplateInstance} from './template-instance.js';\nimport {TemplateResult} from './template-result.js';\nimport {Template} from './template.js';\n\nexport {html, svg, TemplateResult} from '../lit-html.js';\n\ndeclare global {\n  interface Window {\n    ShadyCSS: any;\n  }\n  class ShadowRoot {}\n}\n\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type: string, scopeName: string) =>\n    `${type}--${scopeName}`;\n\nconst verifyShadyCSSVersion = () => {\n  if (typeof window.ShadyCSS === 'undefined') {\n    return false;\n  }\n  if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n    console.warn(\n        `Incompatible ShadyCSS version detected.` +\n        `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and` +\n        `@webcomponents/shadycss@1.3.1.`);\n    return false;\n  }\n  return true;\n};\n\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nconst shadyTemplateFactory = (scopeName: string) =>\n    (result: TemplateResult) => {\n      const cacheKey = getTemplateCacheKey(result.type, scopeName);\n      let templateCache = templateCaches.get(cacheKey);\n      if (templateCache === undefined) {\n        templateCache = new Map<TemplateStringsArray, Template>();\n        templateCaches.set(cacheKey, templateCache);\n      }\n      let template = templateCache.get(result.strings);\n      if (template === undefined) {\n        const element = result.getTemplateElement();\n        if (verifyShadyCSSVersion()) {\n          window.ShadyCSS.prepareTemplateDom(element, scopeName);\n        }\n        template = new Template(result, element);\n        templateCache.set(result.strings, template);\n      }\n      return template;\n    };\n\n\nconst TEMPLATE_TYPES = ['html', 'svg'];\n\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nfunction removeStylesFromLitTemplates(scopeName: string) {\n  TEMPLATE_TYPES.forEach((type) => {\n    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n    if (templates !== undefined) {\n      templates.forEach((template) => {\n        const {element: {content}} = template;\n        // IE 11 doesn't support the iterable param Set constructor\n        const styles = new Set<Element>();\n        Array.from(content.querySelectorAll('style')).forEach((s: Element) => {\n          styles.add(s);\n        });\n        removeNodesFromTemplate(template, styles);\n      });\n    }\n  });\n}\n\nconst shadyRenderSet = new Set<string>();\n\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\nconst ensureStylesScoped =\n    (fragment: DocumentFragment, template: Template, scopeName: string) => {\n      // only scope element template once per scope name\n      if (!shadyRenderSet.has(scopeName)) {\n        shadyRenderSet.add(scopeName);\n        const styleTemplate = document.createElement('template');\n        Array.from(fragment.querySelectorAll('style')).forEach((s: Element) => {\n          styleTemplate.content.appendChild(s);\n        });\n        window.ShadyCSS.prepareTemplateStyles(styleTemplate, scopeName);\n        // Fix templates: note the expectation here is that the given `fragment`\n        // has been generated from the given `template` which contains\n        // the set of templates rendered into this scope.\n        // It is only from this set of initial templates from which styles\n        // will be scoped and removed.\n        removeStylesFromLitTemplates(scopeName);\n        // ApplyShim case\n        if (window.ShadyCSS.nativeShadow) {\n          const style = styleTemplate.content.querySelector('style');\n          if (style !== null) {\n            // Insert style into rendered fragment\n            fragment.insertBefore(style, fragment.firstChild);\n            // Insert into lit-template (for subsequent renders)\n            insertNodeIntoTemplate(\n                template,\n                style.cloneNode(true),\n                template.element.content.firstChild);\n          }\n        }\n      }\n    };\n\n// NOTE: We're copying code from lit-html's `render` method here.\n// We're doing this explicitly because the API for rendering templates is likely\n// to change in the near term.\nexport function render(\n    result: TemplateResult,\n    container: Element|DocumentFragment,\n    scopeName: string) {\n  const templateFactory = shadyTemplateFactory(scopeName);\n  const template = templateFactory(result);\n  let instance = (container as TemplateContainer).__templateInstance;\n\n  // Repeat render, just call update()\n  if (instance !== undefined && instance.template === template &&\n      instance.processor === result.processor) {\n    instance.update(result.values);\n    return;\n  }\n\n  // First render, create a new TemplateInstance and append it\n  instance = new TemplateInstance(template, result.processor, templateFactory);\n  (container as TemplateContainer).__templateInstance = instance;\n\n  const fragment = instance._clone();\n  instance.update(result.values);\n\n  const host = container instanceof ShadowRoot ? container.host : undefined;\n\n  // If there's a shadow host, do ShadyCSS scoping...\n  if (host !== undefined && verifyShadyCSSVersion()) {\n    ensureStylesScoped(fragment, template, scopeName);\n    window.ShadyCSS.styleElement(host);\n  }\n\n  removeNodes(container, container.firstChild);\n  container.appendChild(fragment);\n}\n"]}